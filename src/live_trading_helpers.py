import pandas as pd
import numpy as np
import google.generativeai as genai
import json
from datetime import datetime
import yaml

from myKiteLib import OrderPlacement, kiteAPIs

def load_config(config_path='config/parameters.yml'):
    """Loads the YAML configuration file."""
    try:
        with open(config_path, 'r') as file:
            return yaml.safe_load(file)
    except FileNotFoundError:
        print(f"Error: Configuration file not found at {config_path}")
        exit(1)
    except Exception as e:
        print(f"Error loading configuration file: {e}")
        exit(1)

def get_opinion(tradingsymbol):
    """Generates content using the Gemini API."""
    prompt = f"""You are a financial analyst providing a second opinion on a trading signal.

    CONTEXT:
    - Market: NSE (Indian Stock Market)
    - Trading Symbol: {tradingsymbol}
    - Signal: BUY (generated by ML algorithm)
    - Timeframe: Short to medium term (7 days)

    TASK:
    Analyze whether you agree with this BUY signal based on:
    1. Recent market trends and sector performance
    2. Company fundamentals and recent news
    3. Technical indicators and market sentiment
    4. Overall market conditions
    5. Take into account the latest news on these companies for the last 1-2 days

    RESPONSE FORMAT:
    Return a valid JSON object with this exact structure:
    {{
        "opinion": "Agree|Disagree",
        "confidence": "High|Medium|Low",
        "reasoning": "Your analysis in 80-120 words explaining the key factors",
        "latest_news": "Any key developments reported publicly in the last 1-2 days like quaterly reports or big deals closed or any other news (30-50 words)",
        "about_company": "Tell me briefly about the company (30-50 words)",
    }}

    GUIDELINES:
    - Base analysis on current market data and recent trends
    - Be objective and consider both bullish and bearish factors
    - Focus on analyst recommendations and news

    Provide your analysis now:"""

    try:
        model = genai.GenerativeModel('gemini-1.5-flash')
        response = model.generate_content(prompt)
        return response.text
    except Exception as e:
        print(f"An error occurred during content generation: {e}")
        return None

def run_gemini_bridge(symbol):
    """Processes a single trading symbol through the Gemini API."""
    all_results = []
    generated_content = get_opinion(symbol)    
    if generated_content:
        try:
            content = generated_content.strip()
            if "```json" in content:
                start = content.find("```json") + 7
                end = content.find("```", start)
                if end != -1:
                    content = content[start:end].strip()
            elif not (content.startswith('{') and content.endswith('}')):
                start = content.find('{')
                end = content.rfind('}') + 1
                if start != -1 and end > start:
                    content = content[start:end]
            
            opinion_data = json.loads(content)
            opinion_data = {'tradingsymbol': symbol, **opinion_data}
            all_results.append(opinion_data)
            
        except (json.JSONDecodeError, Exception) as e:
            error_key = "latest_news" if isinstance(e, json.JSONDecodeError) else "about_company"
            error_msg = f"Failed to parse LLM response: {str(e)}" if isinstance(e, json.JSONDecodeError) else f"Unexpected error: {str(e)}"
            all_results.append({
                "tradingsymbol": symbol,
                "opinion": "Error", 
                "confidence": "N/A",
                error_key: error_msg,
                "about_company": f"Invalid response format {content}" if error_key == "latest_news" else ""
            })
    else:
        all_results.append({
            "tradingsymbol": symbol,
            "opinion": "Error",
            "confidence": "N/A",
            "latest_news": "No response generated from LLM",
            "about_company": ""
        })
    return all_results

def get_trade_dates(sys_init):
    """Fetches the initial trade dates for holdings."""
    query = "Select tradingsymbol, min(fill_timestamp) as trade_date_db from kiteconnect.trades where transaction_type = 'BUY' and fill_timestamp >= curdate() - interval 21 day group by 1;"
    df = sys_init.run_query_full(query)
    return df

def get_holdings(callKite, sys_init, order_placement):
    """Fetches and consolidates current holdings and positions."""
    print("INFO: Fetching holdings...")
    holdings_data = callKite.extract_holdings_data()
    positions_data = callKite.extract_positions_data() 
    all_data = holdings_data + positions_data
    
    if not all_data:
        return pd.DataFrame()

    df = pd.DataFrame(all_data)
    dates = get_trade_dates(sys_init)

    merged_df = pd.merge(df, dates, on='tradingsymbol', how='left')
    merged_df['trade_date_db'] = pd.to_datetime(merged_df['trade_date_db'])

    condition = merged_df['data_source'] == 'positions'
    holding_days = (datetime.now() - merged_df['trade_date_db']).dt.days
    merged_df['holding_period'] = np.where(condition, 0, holding_days)

    token_list = merged_df['instrument_token'].unique().tolist()
    
    try:
        ltp_dict = order_placement.get_ltp_live(token_list)
    except Exception as e:
        # Re-raise the exception to be handled by the main loop's refresh logic
        raise e

    merged_df['ltp'] = merged_df['instrument_token'].map(ltp_dict)
    merged_df['pnl'] = merged_df['quantity'] * (merged_df['ltp'] - merged_df['average_price'])
    merged_df['pnl_percent'] = (100 * merged_df['ltp'] / merged_df['average_price']) - 100
    merged_df = merged_df.drop(columns=['trade_date', 'last_price'], errors='ignore')

    # --- Filter for active holdings ---
    initial_rows = len(merged_df)
    merged_df = merged_df[merged_df['quantity'] > 0].copy()
    final_rows = len(merged_df)
    if initial_rows > final_rows:
        print(f"INFO: Filtered out {initial_rows - final_rows} holdings with zero quantity.")

    return merged_df 