import google.generativeai as genai
import os
import argparse
from pathlib import Path
from dotenv import load_dotenv
import sys
import pandas as pd
from datetime import datetime
import json
import sys
import math
sys.tracebacklimit = 0

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from src.data_pipeline import load_config
from myKiteLib import kiteAPIs, system_initialization, OrderPlacement
from kiteconnect.exceptions import KiteException, InputException

# Load environment variables from .env file
load_dotenv()

try:
    # Load the API key and model name from environment variables
    api_key = os.environ["GEMINI_API_KEY"]
    MODEL_NAME = os.environ["MODEL_NAME"]
except KeyError as e:
    print("Please make sure your .env file is configured correctly with GEMINI_API_KEY and MODEL_NAME.")
    exit()

genai.configure(api_key=api_key)

# Use the latest "flash" model, which is fast and versatile.
# For other available models, see: https://ai.google.dev/models/gemini


def get_opinion(tradingsymbol):
    """Generates content using the Gemini API."""
    prompt = f"""You are a financial analyst providing a second opinion on a trading signal.

    CONTEXT:
    - Market: NSE (Indian Stock Market)
    - Trading Symbol: {tradingsymbol}
    - Signal: BUY (generated by ML algorithm)
    - Timeframe: Short to medium term (7 days)

    TASK:
    Analyze whether you agree with this BUY signal based on:
    1. Recent market trends and sector performance
    2. Company fundamentals and recent news
    3. Technical indicators and market sentiment
    4. Overall market conditions
    5. Take into account the latest news on these companies for the last 1-2 days

    RESPONSE FORMAT:
    Return a valid JSON object with this exact structure:
    {{
        "opinion": "Agree|Disagree",
        "confidence": "High|Medium|Low",
        "reasoning": "Your analysis in 80-120 words explaining the key factors",
        "latest_news": "Any key developments reported publicly in the last 1-2 days like quaterly reports or big deals closed or any other news (30-50 words)",
        "about_company": "Tell me briefly about the company (30-50 words)",
    }}

    GUIDELINES:
    - Base analysis on current market data and recent trends
    - Be objective and consider both bullish and bearish factors
    - Focus on analyst recommendations and news

    Provide your analysis now:"""

    try:
        model = genai.GenerativeModel('gemini-2.5-pro')
        response = model.generate_content(prompt)
        return response.text
    except Exception as e:
        print(f"An error occurred during content generation: {e}")
        return None

def save_to_file(content, output_file):
    """Saves the given content to a text file."""
    try:
        with open(output_file, "w", encoding="utf-8") as f:
            f.write(content)
        print(f"Successfully saved the response to '{output_file}'")
    except IOError as e:
        print(f"Error saving to file: {e}")

def main():
    """Main function to run the Gemini bridge script."""

    # The markdown files are now hardcoded
    
    config = load_config('config/parameters.yml')
    data_config = config.get('data', {})
    data_end_date = data_config.get('test_end_date', datetime.now().strftime('%Y-%m-%d'))
    
    signals_df = pd.read_csv('reports/trades/daily_trades.csv')
    # signals_df = signals_df[signals_df['Action'] == 'SIGNAL_NO_EXECUTION']
    signal_prob_df = signals_df[['instrument_token', 'signal_prob']]
    token_list = signals_df['instrument_token'].unique()
    tradingsymbol = []
    # Create mapping from token to tradingsymbol and signal_prob
    systemDetails = system_initialization()
    token_to_symbol = {}
    token_to_prob = {}
    
    for token in token_list:
        result = systemDetails.run_query_limit(f"Select tradingsymbol from kiteconnect.instruments_zerodha where instrument_token = {token}")
        symbol = result[0]
        tradingsymbol.append(symbol)
        token_to_symbol[token] = symbol
        
        # Get signal probability for this token
        prob_row = signal_prob_df[signal_prob_df['instrument_token'] == token]
        if not prob_row.empty:
            token_to_prob[token] = prob_row['signal_prob'].values[0]
        else:
            token_to_prob[token] = None
        
    print(f"Result: {tradingsymbol}")

    # Collect all results in an array
    all_results = []
    
    for token in token_list:
        print(token)
        symbol = token_to_symbol[token]
        signal_prob = token_to_prob[token]
        
        generated_content = get_opinion(symbol)
        
        if generated_content:
            try:
                # Clean the response - sometimes LLM adds extra text before/after JSON
                content = generated_content.strip()
                
                # Find JSON block if it's wrapped in markdown code blocks
                if "```json" in content:
                    start = content.find("```json") + 7
                    end = content.find("```", start)
                    if end != -1:
                        content = content[start:end].strip()
                
                # Find JSON object boundaries if there's extra text
                elif content.startswith('{') and content.endswith('}'):
                    pass  # Already clean JSON
                else:
                    # Try to find JSON object in the response
                    start = content.find('{')
                    end = content.rfind('}') + 1
                    if start != -1 and end > start:
                        content = content[start:end]
                
                # Parse the JSON response from LLM
                opinion_data = json.loads(content)
                opinion_data = {'tradingsymbol': symbol, 'signal_prob': signal_prob, **opinion_data}
                
                # Add to results array
                all_results.append(opinion_data)
                
            except json.JSONDecodeError as e:
                # Add error entry with actual error details
                all_results.append({
                    "tradingsymbol": symbol,
                    "signal_prob": signal_prob,
                    "opinion": "Error", 
                    "confidence": "N/A",
                    "latest_news": f"Failed to parse LLM response: {str(e)}",
                    "about_company": f"Invalid response format {content}"
                })
            except Exception as e:
                all_results.append({
                    "tradingsymbol": symbol,
                    "signal_prob": signal_prob,
                    "opinion": "Error",
                    "confidence": "N/A", 
                    "latest_news": f"Unexpected error: {str(e)}",
                    "about_company": f"Invalid response format {content}"
                })
        else:
            all_results.append({
                "tradingsymbol": symbol,
                "signal_prob": signal_prob,
                "opinion": "Error",
                "confidence": "N/A",
                "latest_news": "No response generated from LLM",
                "about_company": f"Invalid response format {content}"
            })
    
    # Save all results as JSON array to file
    if all_results:
        save_to_file(json.dumps(all_results, indent=2), 'todays_trades/trades.txt')

    order_placement = OrderPlacement()
    order_placement.init_trading()

    order_placement.send_telegram_message("New Trades:")
   
    for item in all_results:
        order_placement.send_telegram_message(json.dumps(item, indent=4))
        trading_symbol = item["tradingsymbol"]
        query = f"Select close from kiteconnect.historical_data_day where timestamp = curdate() and instrument_token in (Select instrument_token from kiteconnect.instruments_zerodha where tradingsymbol = '{trading_symbol}' and exchange = 'NSE');"
        close_price = systemDetails.run_query_limit(query)
        
        if not close_price:
            query = f"Select close from kiteconnect.historical_data_day where timestamp = curdate() and instrument_token in (Select instrument_token from kiteconnect.instruments_zerodha where tradingsymbol = '{trading_symbol}' and exchange = 'BSE');"
            close_price = systemDetails.run_query_limit(query)

        quantity = math.floor(21000/float(close_price[0]))
        print("Symbol: ", trading_symbol, " Quantity: ", quantity)
            
        # Place order on NSE first
        order_id = order_placement.place_market_order_live(
            trading_symbol, 'NSE', 'BUY', quantity, 'CNC', 'Automatic'
        )

        # Check if the order placement returned an exception
        if isinstance(order_id, KiteException):
            # Check for the specific exception to retry on BSE
            if isinstance(order_id, InputException) and 'The instrument you are placing an order for has either expired or does not exist' in str(order_id):
                print(f"Instrument {trading_symbol} not found on NSE. Attempting on BSE.")
                
                # Retry placing the order on BSE
                order_id_bse = order_placement.place_market_order_live(
                    trading_symbol, 'BSE', 'BUY', quantity, 'CNC', 'Automatic'
                )

                if isinstance(order_id_bse, KiteException):
                    # If it failed on BSE as well
                    message = f"Error placing order for {trading_symbol} on BSE after NSE failed. Error: {str(order_id_bse)}"
                    print(message)
                    order_placement.send_telegram_message(message)
                else:
                    # If it succeeded on BSE
                    message = f"Order placed successfully for {trading_symbol} on BSE. Order ID: {order_id_bse}"
                    print(message)
                    order_placement.send_telegram_message(message)
            else:
                # Handle other Kite exceptions
                message = f"Error placing order for {trading_symbol} on NSE: {str(order_id)}"
                print(message)
                order_placement.send_telegram_message(message)
        else:
            # If the order was placed successfully on NSE
            message = f"Order placed successfully for {trading_symbol} on NSE. Order ID: {order_id}"
            print(message)
            order_placement.send_telegram_message(message)

if __name__ == "__main__":
    main() 